// SPDX-License-Identifier: MIT
// Copyright © 2022 The Tvix Authors
// Copyright © 2025 The Snix Project

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: snix/build/protos/build.proto

package buildv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	proto "snix.dev/castore/proto"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A BuildRequest describes the request of something to be run on the builder.
// It is distinct from an actual [Build] that has already happened, or might be
// currently ongoing.
//
// A BuildRequest can be seen as a more normalized version of a Derivation
// (parsed from A-Term), "writing out" some of the Nix-internal details about
// how e.g. environment variables in the build are set.
//
// Nix has some impurities when building a Derivation, for example the --cores option
// ends up as an environment variable in the build, that's not part of the ATerm.
//
// As of now, we serialize this into the BuildRequest, so builders can stay dumb.
// This might change in the future.
//
// There's also a big difference when it comes to how inputs are modelled:
//   - Nix only uses store path (strings) to describe the inputs.
//     As store paths can be input-addressed, a certain store path can contain
//     different contents (as not all store paths are binary reproducible).
//     This requires that for every input-addressed input, the builder has access
//     to either the input's deriver (and needs to build it) or else a trusted
//     source for the built input.
//     to upload input-addressed paths, requiring the trusted users concept.
//   - snix-build records a list of snix.castore.v1.Node as inputs.
//     These map from the store path base name to their contents, relieving the
//     builder from having to "trust" any input-addressed paths, contrary to Nix.
//
// While this approach gives a better hermeticity, it has one downside:
// A BuildRequest can only be sent once the contents of all its inputs are known.
//
// As of now, we're okay to accept this, but it prevents uploading an
// entirely-non-IFD subgraph of BuildRequests eagerly.
//
// FUTUREWORK: We might be introducing another way to refer to inputs, to
// support "send all BuildRequest for a nixpkgs eval to a remote builder and put
// the laptop to sleep" usecases later.
type BuildRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of all root nodes that should be visible in `inputs_dir` at the
	// time of the build.
	// As all references are content-addressed, no additional signatures are
	// needed to substitute / make these available in the build environment.
	// Inputs MUST be sorted by their names.
	Inputs []*proto.Entry `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// The command (and its args) executed as the build script.
	// In the case of a Nix derivation, this is usually
	// ["/path/to/some-bash/bin/bash", "-e", "/path/to/some/builder.sh"].
	CommandArgs []string `protobuf:"bytes,2,rep,name=command_args,json=commandArgs,proto3" json:"command_args,omitempty"`
	// The working dir of the command, relative to the build root.
	// "build", in the case of Nix.
	// This MUST be a clean relative path, without any ".", "..", or superfluous
	// slashes.
	WorkingDir string `protobuf:"bytes,3,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	// A list of "scratch" paths, relative to the build root.
	// These will be write-able during the build.
	// [build, nix/store] in the case of Nix.
	// These MUST be clean relative paths, without any ".", "..", or superfluous
	// slashes, and sorted.
	ScratchPaths []string `protobuf:"bytes,4,rep,name=scratch_paths,json=scratchPaths,proto3" json:"scratch_paths,omitempty"`
	// The path where the castore input nodes will be located at,
	// "nix/store" in case of Nix.
	// Builds might also write into here (Nix builds do that).
	// This MUST be a clean relative path, without any ".", "..", or superfluous
	// slashes.
	InputsDir string `protobuf:"bytes,5,opt,name=inputs_dir,json=inputsDir,proto3" json:"inputs_dir,omitempty"`
	// The list of output paths the build is expected to produce,
	// relative to the root.
	// If the path is not produced, the build is considered to have failed.
	// These MUST be clean relative paths, without any ".", "..", or superfluous
	// slashes, and sorted.
	Outputs []string `protobuf:"bytes,6,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// The list of environment variables and their values that should be set
	// inside the build environment.
	// This includes both environment vars set inside the derivation, as well as
	// more "ephemeral" ones like NIX_BUILD_CORES, controlled by the `--cores`
	// CLI option of `nix-build`.
	// For now, we consume this as an option when turning a Derivation into a BuildRequest,
	// similar to how Nix has a `--cores` option.
	// We don't want to bleed these very nix-specific sandbox impl details into
	// (dumber) builders if we don't have to.
	// Environment variables are sorted by their keys.
	EnvironmentVars []*BuildRequest_EnvVar `protobuf:"bytes,7,rep,name=environment_vars,json=environmentVars,proto3" json:"environment_vars,omitempty"`
	// A set of constraints that need to be satisfied on a build host before a
	// Build can be started.
	Constraints *BuildRequest_BuildConstraints `protobuf:"bytes,8,opt,name=constraints,proto3" json:"constraints,omitempty"`
	// Additional (small) files and their contents that should be placed into the
	// build environment, but outside inputs_dir.
	// Used for passAsFile and structuredAttrs in Nix.
	AdditionalFiles []*BuildRequest_AdditionalFile `protobuf:"bytes,9,rep,name=additional_files,json=additionalFiles,proto3" json:"additional_files,omitempty"`
	// If this is an non-empty list, all paths in `outputs` are scanned for these.
	// For Nix, `refscan_needles` would be populated with the nixbase32 hash parts of
	// every input store path and output store path. The latter is necessary to scan
	// for references between multi-output derivations.
	RefscanNeedles []string `protobuf:"bytes,10,rep,name=refscan_needles,json=refscanNeedles,proto3" json:"refscan_needles,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *BuildRequest) Reset() {
	*x = BuildRequest{}
	mi := &file_snix_build_protos_build_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildRequest) ProtoMessage() {}

func (x *BuildRequest) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildRequest.ProtoReflect.Descriptor instead.
func (*BuildRequest) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{0}
}

func (x *BuildRequest) GetInputs() []*proto.Entry {
	if x != nil {
		return x.Inputs
	}
	return nil
}

func (x *BuildRequest) GetCommandArgs() []string {
	if x != nil {
		return x.CommandArgs
	}
	return nil
}

func (x *BuildRequest) GetWorkingDir() string {
	if x != nil {
		return x.WorkingDir
	}
	return ""
}

func (x *BuildRequest) GetScratchPaths() []string {
	if x != nil {
		return x.ScratchPaths
	}
	return nil
}

func (x *BuildRequest) GetInputsDir() string {
	if x != nil {
		return x.InputsDir
	}
	return ""
}

func (x *BuildRequest) GetOutputs() []string {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *BuildRequest) GetEnvironmentVars() []*BuildRequest_EnvVar {
	if x != nil {
		return x.EnvironmentVars
	}
	return nil
}

func (x *BuildRequest) GetConstraints() *BuildRequest_BuildConstraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

func (x *BuildRequest) GetAdditionalFiles() []*BuildRequest_AdditionalFile {
	if x != nil {
		return x.AdditionalFiles
	}
	return nil
}

func (x *BuildRequest) GetRefscanNeedles() []string {
	if x != nil {
		return x.RefscanNeedles
	}
	return nil
}

// A Build is (one possible) outcome of executing a [BuildRequest].
type Build struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The orginal build request producing the build.
	BuildRequest *BuildRequest `protobuf:"bytes,1,opt,name=build_request,json=buildRequest,proto3" json:"build_request,omitempty"` // <- TODO: define hashing scheme for BuildRequest, refer to it by hash?
	// The outputs that were produced after successfully building.
	// They are sorted by their names.
	Outputs []*proto.Entry `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// Contains the same number of elements as the `outputs` field.
	OutputsNeedles []*Build_OutputNeedles `protobuf:"bytes,3,rep,name=outputs_needles,json=outputsNeedles,proto3" json:"outputs_needles,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Build) Reset() {
	*x = Build{}
	mi := &file_snix_build_protos_build_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Build) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Build) ProtoMessage() {}

func (x *Build) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Build.ProtoReflect.Descriptor instead.
func (*Build) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{1}
}

func (x *Build) GetBuildRequest() *BuildRequest {
	if x != nil {
		return x.BuildRequest
	}
	return nil
}

func (x *Build) GetOutputs() []*proto.Entry {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *Build) GetOutputsNeedles() []*Build_OutputNeedles {
	if x != nil {
		return x.OutputsNeedles
	}
	return nil
}

type BuildRequest_EnvVar struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the environment variable. Must not contain =.
	Key           string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildRequest_EnvVar) Reset() {
	*x = BuildRequest_EnvVar{}
	mi := &file_snix_build_protos_build_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildRequest_EnvVar) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildRequest_EnvVar) ProtoMessage() {}

func (x *BuildRequest_EnvVar) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildRequest_EnvVar.ProtoReflect.Descriptor instead.
func (*BuildRequest_EnvVar) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{0, 0}
}

func (x *BuildRequest_EnvVar) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *BuildRequest_EnvVar) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// BuildConstraints represents certain conditions that must be fulfilled
// inside the build environment to be able to build this.
// Constraints can be things like required architecture and minimum amount of memory.
// The required input paths are *not* represented in here, because it
// wouldn't be hermetic enough - see the comment around inputs too.
type BuildRequest_BuildConstraints struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The system that's needed to execute the build.
	// Must not be empty.
	System string `protobuf:"bytes,1,opt,name=system,proto3" json:"system,omitempty"`
	// The amount of memory required to be available for the build, in bytes.
	MinMemory uint64 `protobuf:"varint,2,opt,name=min_memory,json=minMemory,proto3" json:"min_memory,omitempty"`
	// A list of (absolute) paths that need to be available in the build
	// environment, like `/dev/kvm`.
	// This is distinct from the castore nodes in inputs.
	// TODO: check if these should be individual constraints instead.
	// These MUST be clean absolute paths, without any ".", "..", or superfluous
	// slashes, and sorted.
	AvailableRoPaths []string `protobuf:"bytes,3,rep,name=available_ro_paths,json=availableRoPaths,proto3" json:"available_ro_paths,omitempty"`
	// Whether the build should be able to access the network,
	NetworkAccess bool `protobuf:"varint,4,opt,name=network_access,json=networkAccess,proto3" json:"network_access,omitempty"`
	// Whether to provide a /bin/sh inside the build environment, usually a static bash.
	ProvideBinSh  bool `protobuf:"varint,5,opt,name=provide_bin_sh,json=provideBinSh,proto3" json:"provide_bin_sh,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildRequest_BuildConstraints) Reset() {
	*x = BuildRequest_BuildConstraints{}
	mi := &file_snix_build_protos_build_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildRequest_BuildConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildRequest_BuildConstraints) ProtoMessage() {}

func (x *BuildRequest_BuildConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildRequest_BuildConstraints.ProtoReflect.Descriptor instead.
func (*BuildRequest_BuildConstraints) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{0, 1}
}

func (x *BuildRequest_BuildConstraints) GetSystem() string {
	if x != nil {
		return x.System
	}
	return ""
}

func (x *BuildRequest_BuildConstraints) GetMinMemory() uint64 {
	if x != nil {
		return x.MinMemory
	}
	return 0
}

func (x *BuildRequest_BuildConstraints) GetAvailableRoPaths() []string {
	if x != nil {
		return x.AvailableRoPaths
	}
	return nil
}

func (x *BuildRequest_BuildConstraints) GetNetworkAccess() bool {
	if x != nil {
		return x.NetworkAccess
	}
	return false
}

func (x *BuildRequest_BuildConstraints) GetProvideBinSh() bool {
	if x != nil {
		return x.ProvideBinSh
	}
	return false
}

type BuildRequest_AdditionalFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          string                 `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Contents      []byte                 `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildRequest_AdditionalFile) Reset() {
	*x = BuildRequest_AdditionalFile{}
	mi := &file_snix_build_protos_build_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildRequest_AdditionalFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildRequest_AdditionalFile) ProtoMessage() {}

func (x *BuildRequest_AdditionalFile) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildRequest_AdditionalFile.ProtoReflect.Descriptor instead.
func (*BuildRequest_AdditionalFile) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{0, 2}
}

func (x *BuildRequest_AdditionalFile) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *BuildRequest_AdditionalFile) GetContents() []byte {
	if x != nil {
		return x.Contents
	}
	return nil
}

type Build_OutputNeedles struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The numbers are indexing into `refscan_needles` originally specified in the BuildRequest.
	Needles       []uint64 `protobuf:"varint,1,rep,packed,name=needles,proto3" json:"needles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Build_OutputNeedles) Reset() {
	*x = Build_OutputNeedles{}
	mi := &file_snix_build_protos_build_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Build_OutputNeedles) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Build_OutputNeedles) ProtoMessage() {}

func (x *Build_OutputNeedles) ProtoReflect() protoreflect.Message {
	mi := &file_snix_build_protos_build_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Build_OutputNeedles.ProtoReflect.Descriptor instead.
func (*Build_OutputNeedles) Descriptor() ([]byte, []int) {
	return file_snix_build_protos_build_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Build_OutputNeedles) GetNeedles() []uint64 {
	if x != nil {
		return x.Needles
	}
	return nil
}

var File_snix_build_protos_build_proto protoreflect.FileDescriptor

const file_snix_build_protos_build_proto_rawDesc = "" +
	"\n" +
	"\x1dsnix/build/protos/build.proto\x12\rsnix.build.v1\x1a!snix/castore/protos/castore.proto\"\xba\x06\n" +
	"\fBuildRequest\x12.\n" +
	"\x06inputs\x18\x01 \x03(\v2\x16.snix.castore.v1.EntryR\x06inputs\x12!\n" +
	"\fcommand_args\x18\x02 \x03(\tR\vcommandArgs\x12\x1f\n" +
	"\vworking_dir\x18\x03 \x01(\tR\n" +
	"workingDir\x12#\n" +
	"\rscratch_paths\x18\x04 \x03(\tR\fscratchPaths\x12\x1d\n" +
	"\n" +
	"inputs_dir\x18\x05 \x01(\tR\tinputsDir\x12\x18\n" +
	"\aoutputs\x18\x06 \x03(\tR\aoutputs\x12M\n" +
	"\x10environment_vars\x18\a \x03(\v2\".snix.build.v1.BuildRequest.EnvVarR\x0fenvironmentVars\x12N\n" +
	"\vconstraints\x18\b \x01(\v2,.snix.build.v1.BuildRequest.BuildConstraintsR\vconstraints\x12U\n" +
	"\x10additional_files\x18\t \x03(\v2*.snix.build.v1.BuildRequest.AdditionalFileR\x0fadditionalFiles\x12'\n" +
	"\x0frefscan_needles\x18\n" +
	" \x03(\tR\x0erefscanNeedles\x1a0\n" +
	"\x06EnvVar\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x1a\xc4\x01\n" +
	"\x10BuildConstraints\x12\x16\n" +
	"\x06system\x18\x01 \x01(\tR\x06system\x12\x1d\n" +
	"\n" +
	"min_memory\x18\x02 \x01(\x04R\tminMemory\x12,\n" +
	"\x12available_ro_paths\x18\x03 \x03(\tR\x10availableRoPaths\x12%\n" +
	"\x0enetwork_access\x18\x04 \x01(\bR\rnetworkAccess\x12$\n" +
	"\x0eprovide_bin_sh\x18\x05 \x01(\bR\fprovideBinSh\x1a@\n" +
	"\x0eAdditionalFile\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x1a\n" +
	"\bcontents\x18\x02 \x01(\fR\bcontents\"\xf3\x01\n" +
	"\x05Build\x12@\n" +
	"\rbuild_request\x18\x01 \x01(\v2\x1b.snix.build.v1.BuildRequestR\fbuildRequest\x120\n" +
	"\aoutputs\x18\x02 \x03(\v2\x16.snix.castore.v1.EntryR\aoutputs\x12K\n" +
	"\x0foutputs_needles\x18\x03 \x03(\v2\".snix.build.v1.Build.OutputNeedlesR\x0eoutputsNeedles\x1a)\n" +
	"\rOutputNeedles\x12\x18\n" +
	"\aneedles\x18\x01 \x03(\x04R\aneedlesB\x1eZ\x1csnix.dev/build/proto;buildv1b\x06proto3"

var (
	file_snix_build_protos_build_proto_rawDescOnce sync.Once
	file_snix_build_protos_build_proto_rawDescData []byte
)

func file_snix_build_protos_build_proto_rawDescGZIP() []byte {
	file_snix_build_protos_build_proto_rawDescOnce.Do(func() {
		file_snix_build_protos_build_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_snix_build_protos_build_proto_rawDesc), len(file_snix_build_protos_build_proto_rawDesc)))
	})
	return file_snix_build_protos_build_proto_rawDescData
}

var file_snix_build_protos_build_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_snix_build_protos_build_proto_goTypes = []any{
	(*BuildRequest)(nil),                  // 0: snix.build.v1.BuildRequest
	(*Build)(nil),                         // 1: snix.build.v1.Build
	(*BuildRequest_EnvVar)(nil),           // 2: snix.build.v1.BuildRequest.EnvVar
	(*BuildRequest_BuildConstraints)(nil), // 3: snix.build.v1.BuildRequest.BuildConstraints
	(*BuildRequest_AdditionalFile)(nil),   // 4: snix.build.v1.BuildRequest.AdditionalFile
	(*Build_OutputNeedles)(nil),           // 5: snix.build.v1.Build.OutputNeedles
	(*proto.Entry)(nil),                   // 6: snix.castore.v1.Entry
}
var file_snix_build_protos_build_proto_depIdxs = []int32{
	6, // 0: snix.build.v1.BuildRequest.inputs:type_name -> snix.castore.v1.Entry
	2, // 1: snix.build.v1.BuildRequest.environment_vars:type_name -> snix.build.v1.BuildRequest.EnvVar
	3, // 2: snix.build.v1.BuildRequest.constraints:type_name -> snix.build.v1.BuildRequest.BuildConstraints
	4, // 3: snix.build.v1.BuildRequest.additional_files:type_name -> snix.build.v1.BuildRequest.AdditionalFile
	0, // 4: snix.build.v1.Build.build_request:type_name -> snix.build.v1.BuildRequest
	6, // 5: snix.build.v1.Build.outputs:type_name -> snix.castore.v1.Entry
	5, // 6: snix.build.v1.Build.outputs_needles:type_name -> snix.build.v1.Build.OutputNeedles
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_snix_build_protos_build_proto_init() }
func file_snix_build_protos_build_proto_init() {
	if File_snix_build_protos_build_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_snix_build_protos_build_proto_rawDesc), len(file_snix_build_protos_build_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_snix_build_protos_build_proto_goTypes,
		DependencyIndexes: file_snix_build_protos_build_proto_depIdxs,
		MessageInfos:      file_snix_build_protos_build_proto_msgTypes,
	}.Build()
	File_snix_build_protos_build_proto = out.File
	file_snix_build_protos_build_proto_goTypes = nil
	file_snix_build_protos_build_proto_depIdxs = nil
}
